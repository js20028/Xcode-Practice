* compactMap - 배열에서 nil 제거, 옵셔널바인딩해줌, 1차원 배열일때만 가능
flatMap - 2차원배열을 1차원 배열로 flatten하게 만들어줌, 1차원배열일때는 compactMap과 동일한 결과를 냄
ex) 
let array2: [[Int?]] = [[1, 2, 3], [nil, 5], [6, nil], [nil, nil]]
let flatMapTest2 = array2.flatMap { $0 }.compactMap{ $0 }

<출력>
// flatMapTest2 : [1, 2, 3, 5, 6]

* UserDefaults - set 메서드로 데이터 저장, object 메서드로 데이터 로드, object 메서드는 Any 타입으로 리턴됨

* didSet - 프로퍼티의 값이 변경된 직후에 호출
* willSet - 프로퍼티의 값이 변경되기 직전에 호출

* dictionary

* ns타입 - 대부분 Objective-C의 타입

* content hugging - 텍스트의 이미지에따라 크기가 결정되는 컨텐츠(버튼, 라벨 등)의 고유크기가 있는데 더 늘어나는것에 대해 저항하는 제약, 우선순위가 낮은것이 늘어남
* content compression resistance - 줄어드는것에 대해 저항하는 제약(압축에대한 저항), 우선순위가 높은것이 크기가 줄어들지않음

* 랜덤함수 
[swift 4.2 이전]
arc4random() -> UInt32 - 0~2^32-1의 범위의 난수 반환
arc4random_uniform(UInt32) -> UInt32 - 파라미터로 넣은 UInt32-1 사이의 난수 리턴
drand48() -> Double - 0부터 1.0 사이의 난수 리턴
arc4random_uniform(5) // 0~4 사이의 난수 랜덤생성, 배열의 인덱스요소에 접근하려면 Int(arc4random_uniform(5))로 사용

[swift 4.2 이후]
Int.rand(in: 0..5) // 0~5사이의 Int난수 생성


* print 함수 - 매개변수로 separator, terminator 생략되어있음
separator : 디폴트는 “ “ 프린트 , 사이에 원하는 문자로 구문가능
terminator : 디폴트는 “\n”


* tuple - 여러 값을 하나의 개체에 일시적으로 묶는방법, 함수에서 여러 값들을 한번에 반환 가능
ex)
빈 튜플은 Void, typealias Void = ()
let myTuple = (10, 12.1, “Hi”) 
튜플의 요소에 접근하려면 myTuple.0  // 10
let (myInt, myFloat, myString) = myTuple // myInt = 10, myFloat = 12.1, myString = “Hi”
let myTuple = (count: 10, length: 12.1, message: “Hi”) // 각 요소에 이름설정가능, 접근할때 myTuple.count 로 가능

* if문에서 ,는 and와 같음 여러 옵셔널변수를 언래핑할수있음

* !로 선언하면 optional로 사용되지 않을때 자동으로 언래핑함

* AnyObject는 클래스타입의 인스턴스 저장가능
  Any는 클래스 포함 어느 자료형도 저장가능

* truncatingRemainder(dividingBy: 나눌 수) 
나머지 값을 구하는 일반적인 방법은 % 이지만, 이는 Int끼리의 계산에만 적용이 가능

---------------------------------------------------------------------------------------------------------------------
* 다른화면으로 데이터 전달하기(segue로 push)
<segue로 push> - 화면이 오른쪽에서 왼쪽으로 생김
버튼에서 Show 선택

다른화면으로 데이터 전달
전달할 페이지에 nameLabel아울렛변수 만들기
var name: String? 프로퍼티 정의
prepare메서드를 뷰컨트롤러에 오버라이드, 이렇게하면 세그웨이를 실행하기 직전에 프리페어 메소드가 자동으로 호출됨
prepare메서드 안에 segue.destination 작성, destination은 전환하려는 뷰컨트롤러의 인스턴스를 가져올수 있음
if let viewController = segue.destination as? SeguePushViewController 로 다운캐스팅 
전달받는 페이지에서 데이터 출력
backbutton은 self.navigationController?.popViewController로 함

<Segue로 Present> - 화면이 밑에서 위로 덮힘
버튼에서 present modally 선택
백버튼은 self.presentingViewController?.dismiss로 함


* 이전화면으로 데이터 전달(delegate 패턴)
let viewController = self.storyboard?.instantiateViewController 로 스토리보드의 뷰컨트롤러를
인스턴스화 시켜야함, 옵셔널로 반환되므로 가드문 사용
self.navigationController?.pushViewController로 화면 푸시

<코드로 present>
let viewController = self.storyboard?.instantiateViewController 로 스토리보드의 뷰컨트롤러를
인스턴스화 시켜야함, 옵셔널로 반환되므로 가드문 사용
self.present(viewController, animated: true, completion: nil) 로 화면 프레젠트
풀스크린은 viewController.modalPresentationStyle = .fullScreen 추가

이전화면으로 데이터 전달
delegate 패턴 사용
root view 컨트롤러에 라벨 추가(nameLabel)
데이터를 넘겨줄 페이지에 프로토콜 정의, AnyObject 상속 sendData(name: String) 함수 정의
weak var delegate: SendDataDelegate? 델리게이트 변수앞에는 weak를 붙여야함
페이지를 dismiss하기 전에 self.delegate?.sendData(name: "abc") 코드 작성
-> 데이터를 전달받은 뷰컨트롤러에서 델리게이트 프로토콜을 채택하고 델리게이트를 위임받으면
    이전화면 뷰컨트롤러에서 정의된 sendData함수가 실행됨
이전화면에서 프레젠트하기 전에 viewController.delegate = self로 초기화하면 델리게이트를 위임받음
이전화면에서 프로토콜을 채택하고 프로토콜을 준수하기위해 정의했던 함수를 작성함 
---------------------------------------------------------------------------------------------------------------------

* ??(Nil-coalescing)
언래핑하고자 하는 옵셔널 값을 ?? nil 병합 연산자 좌측에 놓고, 옵셔널에 값이 없을 때 우측에 대신할 값을 적으면 됨
ex)
if let name = name {
     print("hello, \(name)")
} else {
     print("hello, what's your name?")
}

=> print("hello, " + (name ?? "what's your name?"))
name의 값이 있는경우에는 name의 옵셔널을 언래핑해서 출력하고 nil이면 ?? 우측의 값으로 대체함


* as - 자식인스턴스 as 부모클래스, 서브클래스의 인스턴스를 슈퍼클래스 타입으로 참조, 업캐스팅은 항상 성공함
  상속관계가 있는 클래스들 끼리만 타입캐스팅 가능
* as?, as! - 부모인스턴스 as? or as! 자식클래스, 슈퍼클래스의 인스턴스를 서브클래스 타입으로 참조, 실패할수도있기때문에 ?, !를 붙여서 사용
	실패할경우 nil을 리턴하므로 옵셔널타입으로 선언해야함

* if let 과 다르게 guard let은 선언한 변수를 guard문 밖에서도 쓸수있음
